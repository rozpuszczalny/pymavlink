/*
MAVLink protocol implementation for node.js (auto-generated by mavgen_typescript.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

// TODO: review methods copied from javascript generator
// TODO: review architecture
// TODO: do module declaration

import { jspack } from 'jspack';
import * as _ from 'underscore';
import * as events from 'events';
import * as util from 'util';

export module mavlink {
    // readonly MAVLINK_TYPE_CHAR = 0;
    // readonly MAVLINK_TYPE_UINT8_T = 1;
    // readonly MAVLINK_TYPE_INT8_T = 2;
    // readonly MAVLINK_TYPE_UINT16_T = 3;
    // readonly MAVLINK_TYPE_INT16_T = 4;
    // readonly MAVLINK_TYPE_UINT32_T = 5;
    // readonly MAVLINK_TYPE_INT32_T = 6;
    // readonly MAVLINK_TYPE_UINT64_T = 7;
    // readonly MAVLINK_TYPE_INT64_T = 8;
    // readonly MAVLINK_TYPE_FLOAT = 9;
    // readonly MAVLINK_TYPE_DOUBLE = 10;

    class char extends String { }
    class uint8_t extends Number { }
    class int8_t extends Number { }
    class uint16_t extends Number { }
    class int16_t extends Number { }
    class uint32_t extends Number { }
    class int32_t extends Number { }
    // am I sure?
    class uint64_t extends Array {
        constructor(array: any[]) {
            super();
            return [array[0], array[1], true];
        }
    }
    // am I sure?
    class int64_t extends Array {
        constructor(array: any[]) {
            super();
            return [array[0], array[1], false];
        }
    }
    class float extends Number { }
    class double extends Number { }

    // Mavlink headers incorporate sequence, source system (platform) and source component. 
    class header {
        constructor(public msgId: number,
            public mlen: number = 0,
            public seq: number = 0,
            public srcSystem: number = 0,
            public srcComponent: number = 0) { }

        pack(): number[] {
            return jspack.Pack('BBBBBB', [
                "${PROTOCOL_MARKER}",
                this.mlen,
                this.seq,
                this.srcSystem,
                this.srcComponent,
                this.msgId
            ]);
        }
    }

    export class MAVLink extends events.EventEmitter {
        seq: number = 0;
        buf: Buffer = new Buffer(0);
        bufInError: Buffer = new Buffer(0);
        expected_length: number = 6;
        have_prefix_error: boolean = false;
        protocol_marker: number = 254;
        little_endian: boolean = true;
        crc_extra: boolean = true;
        sort_fields: boolean = true;
        total_packets_sent: number = 0;
        total_bytes_sent: number = 0;
        total_packets_received: number = 0;
        total_bytes_received: number = 0;
        total_receive_errors: number = 0;
        startup_time: number = Date.now(); // Should be date?
        file: any; // WHAT IS THIS

        constructor(private logger: any,
            public srcSystem: number = 0,
            public srcComponent: number = 0) {
            super();
            // util.inherits(this, events.EventEmitter);
            // events.EventEmitter.call(this);
        }

        log(level: any, message?: any): void {
            if (this.logger) {
                if (message) {
                    this.logger.info(level, message);
                } else {
                    this.logger.info(level); // it's message, really
                }
            }
        }

        send(mavmsg: message): void {
            let buf = mavmsg.pack(this);
            this.file.write(buf);
            this.seq = (this.seq + 1) % 256;
            this.total_packets_sent += 1;
            this.total_bytes_sent += buf.length;
        }

        bytes_needed(): number {
            let result = this.expected_length - this.buf.length;
            return (result <= 0) ? 1 : result;
        }

        pushBuffer(data?: Buffer): void {
            if (data) {
                this.buf = Buffer.concat([this.buf, data]);
                this.total_bytes_received += data.length;
            }
        }

        // Decode prefix.  Elides the prefix.
        parsePrefix(): void {
            // Test for a message prefix.
            if (this.buf.length >= 1 && this.buf[0] != 254) {

                // Strip the offending initial byte and throw an error.
                var badPrefix = this.buf[0];
                this.bufInError = this.buf.slice(0, 1);
                this.buf = this.buf.slice(1);
                this.expected_length = 6;

                // TODO: enable subsequent prefix error suppression if robust_parsing is implemented
                //if(!this.have_prefix_error) {
                //    this.have_prefix_error = true;
                throw new Error("Bad prefix (" + badPrefix + ")");
                //}

            }
        }

        // Determine the length.  Leaves buffer untouched.
        parseLength(): void {

            if (this.buf.length >= 2) {
                var unpacked = jspack.Unpack('BB', this.buf.slice(0, 2));
                this.expected_length = unpacked[1] + 8; // length of message + header + CRC
            }

        }

        // input some data bytes, possibly returning a new message
        parseChar(c?: Buffer): message {
            let m: message = null;

            try {

                this.pushBuffer(c);
                this.parsePrefix();
                this.parseLength();
                m = this.parsePayload();

            } catch (e) {

                this.log('error', e.message);
                this.total_receive_errors += 1;
                m = new mavlink.messages.bad_data(this.bufInError, e.message);
                this.bufInError = new Buffer(0);

            }

            if (null != m) {
                this.emit(m.name, m);
                this.emit('message', m);
            }

            return m;

        }

        parsePayload(): message {

            var m: message = null;

            // If we have enough bytes to try and read it, read it.
            if (this.expected_length >= 8 && this.buf.length >= this.expected_length) {

                // Slice off the expected packet length, reset expectation to be to find a header.
                var mbuf = this.buf.slice(0, this.expected_length);
                // TODO: slicing off the buffer should depend on the error produced by the decode() function
                // - if a message we find a well formed message, cut-off the expected_length
                // - if the message is not well formed (correct prefix by accident), cut-off 1 char only
                this.buf = this.buf.slice(this.expected_length);
                this.expected_length = 6;

                // w.info("Attempting to parse packet, message candidate buffer is ["+mbuf.toByteArray()+"]");

                try {
                    m = this.decode(mbuf);
                    this.total_packets_received += 1;
                }
                catch (e) {
                    // Set buffer in question and re-throw to generic error handling
                    this.bufInError = mbuf;
                    throw e;
                }
            }

            return m;

        }

        // input some data bytes, possibly returning an array of new messages
        parseBuffer(s: Buffer): message[] {

            // Get a message, if one is available in the stream.
            var m = this.parseChar(s);

            // No messages available, bail.
            if (null === m) {
                return null;
            }

            // While more valid messages can be read from the existing buffer, add
            // them to the array of new messages and return them.
            let ret = [m];
            while (true) {
                m = this.parseChar();
                if (null === m) {
                    // No more messages left.
                    return ret;
                }
                ret.push(m);
            }
        }

        /* decode a buffer as a MAVLink message */
        decode(msgbuf: Buffer): message {
            var magic, mlen, seq, srcSystem, srcComponent, unpacked: number[], msgId;

            // decode the header
            try {
                unpacked = jspack.Unpack('cBBBBB', msgbuf.slice(0, 6));
                magic = unpacked[0];
                mlen = unpacked[1];
                seq = unpacked[2];
                srcSystem = unpacked[3];
                srcComponent = unpacked[4];
                msgId = unpacked[5];
            }
            catch (e) {
                throw new Error('Unable to unpack MAVLink header: ' + e.message);
            }

            if (magic.charCodeAt(0) != 254) {
                throw new Error("Invalid MAVLink prefix (" + magic.charCodeAt(0) + ")");
            }

            if (mlen != msgbuf.length - 8) {
                throw new Error("Invalid MAVLink message length.  Got " + (msgbuf.length - 8) + " expected " + mlen + ", msgId=" + msgId);
            }

            if (false === _.has(mavlink.map, msgId)) {
                throw new Error("Unknown MAVLink message ID (" + msgId + ")");
            }

            // decode the payload
            // refs: (fmt, type, order_map, crc_extra) = mavlink.map[msgId]
            var decoder = mavlink.map[msgId];

            // decode the checksum
            try {
                var receivedChecksum = jspack.Unpack('<H', msgbuf.slice(msgbuf.length - 2));
            } catch (e) {
                throw new Error("Unable to unpack MAVLink CRC: " + e.message);
            }

            var messageChecksum = mavlink.x25Crc(msgbuf.slice(1, msgbuf.length - 2));

            // Assuming using crc_extra = True.  See the message.prototype.pack() function.
            messageChecksum = mavlink.x25Crc([decoder.crc_extra], messageChecksum);

            if (receivedChecksum != messageChecksum) {
                throw new Error('invalid MAVLink CRC in msgID ' + msgId + ', got 0x' + receivedChecksum + ' checksum, calculated payload checkum as 0x' + messageChecksum);
            }

            // Decode the payload and reorder the fields to match the order map.
            try {
                var t = jspack.Unpack(decoder.format, msgbuf.slice(6, msgbuf.length));
            }
            catch (e) {
                throw new Error('Unable to unpack MAVLink payload type=' + decoder.type + ' format=' + decoder.format + ' payloadLength=' + msgbuf.slice(6, -2).length + ': ' + e.message);
            }

            // Reorder the fields to match the order map
            var args = [];
            _.each(t, function (e, i, l) {
                args[i] = t[decoder.order_map[i]]
            });

            // construct the message object
            try {
                var m = new decoder.type(args);
                m.set.call(m, args);
            }
            catch (e) {
                throw new Error('Unable to instantiate MAVLink message of type ' + decoder.type + ' : ' + e.message);
            }
            m.msgbuf = msgbuf;
            m.payload = msgbuf.slice(6);
            m.crc = receivedChecksum;
            m.header = new mavlink.header(msgId, mlen, seq, srcSystem, srcComponent);
            this.log(m);
            return m;
        }

    }

    class message {
        id: number;
        fieldnames: string[];
        header: header;
        payload: number[];
        msgbuf: number[] | Buffer;
        name: string;
        new() {
            return this;
        }
        constructor() { }
        set(args: any[]): void {
            _.each(this.fieldnames, (e, i) => {
                this[e] = args[i];
            });
        }

        pack(mav: MAVLink, crc_extra?: number, payload?: number[]): number[] {
            this.payload = payload;
            this.header = new mavlink.header(
                this.id,
                payload.length,
                mav.seq,
                mav.srcSystem,
                mav.srcComponent
            );
            this.msgbuf = this.header.pack().concat(payload);
            let crc = mavlink.x25Crc(this.msgbuf.slice(1));

            crc = mavlink.x25Crc([crc_extra], crc);
            this.msgbuf = this.msgbuf.concat(jspack.Pack('<H', [crc]));

            return this.msgbuf;
        }
    }

    class flight_information extends message {
        constructor(public time_boot_ms, public arming_time_utc, public takeoff_time_utc, public flight_uuid) {
            super();
            // TODO: Rest of fields (fieldnames etc.)
        }
    }
    class bad_data extends message {
        constructor(public data: Buffer | number[], public reason: string) {
            super();
            this.id = MSG_ID.BAD_DATA;
            this.msgbuf = data;
        }
    }

    class messages {
        static bad_data = bad_data;
    }

    class map_element {
        format: string;
        type: any; // TODO: Type as message - interference?
        order_map: number[];
        crc_extra: number;
    }

    // TODO: Consider using const enum
    export enum MSG_ID {
        BAD_DATA = -1
    }

    export class mavlink {
        static x25Crc(buffer: number[] | Buffer, crc: number = 0xffff): number {
            let bytes = buffer;

            _.each(bytes, (e) => {
                let tmp = e ^ (crc & 0xff);
                tmp = (tmp ^ (tmp << 4)) & 0xff;
                crc = (crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
                crc = crc & 0xffff;
            });

            return crc;
        }

        WIRE_PROTOCOL_VERSION: string = "";

        // Not sure if it's needed.
        readonly MAVLINK_TYPE_CHAR = 0;
        readonly MAVLINK_TYPE_UINT8_T = 1;
        readonly MAVLINK_TYPE_INT8_T = 2;
        readonly MAVLINK_TYPE_UINT16_T = 3;
        readonly MAVLINK_TYPE_INT16_T = 4;
        readonly MAVLINK_TYPE_UINT32_T = 5;
        readonly MAVLINK_TYPE_INT32_T = 6;
        readonly MAVLINK_TYPE_UINT64_T = 7;
        readonly MAVLINK_TYPE_INT64_T = 8;
        readonly MAVLINK_TYPE_FLOAT = 9;
        readonly MAVLINK_TYPE_DOUBLE = 10;

        static header = header;
        static messages = messages;
        static map: map_element[];
    }

    mavlink.map = [{
        format: "A",
        type: mavlink.messages.bad_data,
        order_map: [0, 1],
        crc_extra: 0
    }];
}